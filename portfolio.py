# -*- coding: utf-8 -*-
"""Portfolio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11I00glwiXVnETU1Fn0pz75Vhwf8efTvf
"""

# Description: This program attempts to optimize a users portfolio using the Efficient Frontier package.

# Import Libraries
from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

# Getting stock symbols/tickers for the portfolio
# (FAANG/TM) Facebook, Apple, Amazon, Netflix, Google, Tesla, Microsoft
assets = ['FB', 'AMZN', 'AAPL', 'NFLX', 'GOOG', 'TSLA', 'MSFT']

# Assign weights to stocks in the portfolio
weights = np.array([0.14285714, 0.14285714, 0.14285714, 0.14285714, 0.14285714, 0.14285714, 0.14285714])

# Get the stock/portfolio starting date
stockStartDate = '2013-01-01' # First full trading year for FB

# Get todays date
today = datetime.today().strftime('%Y-%m-%d')
today

# Create a dataframe to store the adj close price of the portfolio stocks
df = pd.DataFrame()

# Store the adj close price data into the df
for stock in assets:
  df[stock] = web.DataReader(stock, data_source='yahoo', start = stockStartDate, end= today)['Adj Close']

# Show the df
df

# Visually show the stock/portfolio 
title = 'Portfolio Adj. Close Price History'

# Get the stocks 
my_stocks = df

# Create and plot the df graph
for c in my_stocks.columns.values:
  plt.plot(my_stocks[c], label = c)

plt.title(title)
plt.xlabel('Date', fontsize = 18)
plt.ylabel('Adj. Close Price USD', fontsize = 18)
plt.legend(my_stocks.columns.values, loc = 'upper left')

# Show the daily simple return of each stock in the portfolio
returns = df.pct_change()
returns

# Analyze the annualized covariance matrix of the stocks in the portfolio.
# Covariance matrix measures two variables in how they vary/move together. 
# So the matrix is the directional relationship between two assets prices. 
# Taking the sqrt of this matrix's variance/std deviation gives the stocks volatility. 
cov_matrix_annual = returns.cov() * 252
cov_matrix_annual

# Calculate the portfolio variance 
port_variance = np.dot(weights.T, np.dot(cov_matrix_annual, weights))
port_variance

# Calculate the portfolio volatility aka std deviation aka risk
port_volatility = np.sqrt(port_variance)
port_volatility

# Calculate the annual portfolio return 
portfolioSimpleAnnualReturn = np.sum(returns.mean() * weights) * 252
portfolioSimpleAnnualReturn

# Show the expected annual return, volatility (risk), and variance
percent_var = str(round(port_variance, 2) * 100) + '%'
percent_vols = str(round(port_volatility, 2) * 100) + '%'
percent_ret = str(round(portfolioSimpleAnnualReturn, 2) * 100) + '%'
print("Before Optimization")
print("Expected annual return: "+ percent_ret)
print("Annual volatility / risk: "+ percent_vols)
print("Annual variance: "+ percent_var)
# There is a python package that can analyze the portfolio and give a higher return with a lower risk.

pip install PyPortfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

# Optimization of the portfolio
# Calculate the expected returns and the annualized sample covariance matrix of asset returns
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

# Optimize for max sharpe ratio
ef = EfficientFrontier(mu, S)
weights = ef.max_sharpe()
cleaned_weights = ef.clean_weights()
print("After Optimization")
print(cleaned_weights)
ef.portfolio_performance(verbose = True)

0.04904 + 0.17874 + 0.06929 + 0.25513 + 0.0 + 0.19851 + 0.24929

# Get the discrete allocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

latest_prices = get_latest_prices(df)
weights = cleaned_weights
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value = 15000)

allocation , leftover = da.lp_portfolio()
print("Discrete allocation:",allocation)
print("Funds remaining: ${:.2f}".format(leftover))